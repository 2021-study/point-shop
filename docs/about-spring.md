## Spring

* 각종 기술 부채들에 대한 note...

## @EnableScheduling 을 이용한 배치성 로직 처리
* 원칙적으로 리소스 소모가 많은 작업을 WAS에서 처리하기 보다는 별도 Batch 처리로 분리하는게 적절함...
* Spring boot에서 지원하는 스케쥴링 기능을 사용하여 간단하게 동작하는 배치성 로직을 쉽게 구현할 수 있음.
* http://jmlim.github.io/spring/2018/11/27/spring-boot-schedule/
* 적용 가능 비즈니스(예시)
  * 회원 등급 업데이트
  * 지급 포인트 만료 처리


## 분산락 구현
* 프로젝트 시잘할 때 이 서비스를 단일 인스턴스만 배포한다고 가정을 했지만...
* "```대용량```" 처리를 고려한다면, 클라우드 기반 인프라 환경(ex. 쿠버네티스)에 앱이 배포가 된다라고 가정하면, 운영 환경에서 우리의 서버 인스턴스는 충분히 여러대가 띄워질 것을 염두에 두면 좋을 듯.
* 분산된 운영 서버 인스턴스 마다 DB에 접근하면서 발생하는 Lock 이슈는 분산락(Distributed lock) 관점에서 접근을 해보자. 
  * 여러 인스턴스가 받은 무수한 요청들 운영 DB 자원에 접근하려고 할 때 발생하는 일종의 동시성 문제를 해결해야함.
  * 기본적으로 Spring의 ```@Transactional```의 범위는 로컬 이므로, 다수의 인스턴스가 활성화 된 분산 환경에서 더 적절한 트랜잭션 관리 부분이 필요함.
* 성능과 DB 데이터 무결성 사이에서 그 균형을 잡는 것이 포인트.

### 분산락 기능 적용이 필요한 요건
* 주문 처리
  * 주문 생성과 함께 재고 소진, 구매 유저의 포인트 차감 까지 단일 트랜잭션으로 묶여야함
  * 이때 **상품 재고 소진** 과정에서 다수의 유저의 동시 접근이 발생하는 부분
  
### 1. JPA 낙관적 락 구현
* JPA 관련된 스터디 자료가 많아 구글에서 낙관적 락을 구현한 사례가 많음.
* 다른 방법에 비해서 병목(DB 접근 관련) 리스크가 있지 않을까 하는 생각

### 2. Redis Cache 이용
* 캐시를 이용해 실제 운영 레벨에서 적용한 사례가 많음.
* https://hyperconnect.github.io/2019/11/15/redis-distributed-lock-1.html
* https://dev-yeye.tistory.com/113

### 3. MYSQL DB를 이용
* 이런 관점도 있음.
* https://techblog.woowahan.com/2631/

### 4. RabbitMQ와 같은 메시징 큐 이용
* Kafka의 경우 1개의 파티션만 가진 토픽을 이용해 볼 수 있음.
  * 요청만 큐에 쌓고 컨슘하는 쪽에서 순차적으로 컨슘하면서 주문을 처리하는 방식(Event-Driven)
* RabbitMQ를 공부할 겸 도입을 해보는 것도 좋을 듯..(어짜피 나중에도 쓸 일이 있을지도 모르지)